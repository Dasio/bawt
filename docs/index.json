[
{
	"uri": "https://capstonelabs.github.io/bawt/developers/design/event-loop/",
	"title": "Event Loop",
	"tags": [],
	"description": "The event loop is designed to keep Bawt&#39;s internal state in line as well as pass messages to listeners.",
	"content": " Core to bawt is listening to an event queue that Slack provides in the form of their Real Time Messaging API. We process this queue through an event loop, which takes it where it needs to go in bawt mainly for internal purposes.\ngraph LR; A[slack.RTMEvent] --|Process Event| B(handleRTMEvent) BB -.- C(slack.LatencyReport) BB -.- D(slack.RTMError) BB -.- E(slack.ConnectedEvent) BB -.- F(slack.DisconnectedEvent) BB -.- G(slack.InvalidAuthEvent) BB -.- H(slack.ConnectingEvent) BB -.- I(slack.HelloEvent) BB -.- J(slack.MessageEvent) BB -.- K(slack.UserChangeEvent) BB -.- L(slack.ChannelRenameEvent) BB -.- M(slack.ChannelJoinedEvent) BB -.- N(slack.ChannelCreatedEvent) BB -.- O(slack.ChannelDeletedEvent) BB -.- P(slack.ChannelArchiveEvent) BB -.- Q(slack.GroupRenameEvent) BB -.- R(slack.GroupJoinedEvent) BB -.- S(slack.GroupCreatedEvent) BB -.- T(slack.GroupCloseEvent) BB -.- U(slack.GroupArchiveEvent) BB -.- V(slack.GroupUnarchivedEvent) BB -.- W(slack.IMCreatedEvent) BB -.- X(slack.IMOpenEvent) BB -.- Y(slack.IMCloseEvent) BB -.- Z(slack.AckErrorEvent) BB -.- AA(slack.ConnectionErrorEvent) B --|First| BB{Event Loop} B --|Second| CC(Send to Listeners Loop) click J \"/bawt/developers/design/event-loop/#slack-messageevent\" \"Click for more details\"  bawt\u0026rsquo;s ordered execution of the event loop and the listeners is intentional. Many of bawt\u0026rsquo;s plugins assume that bawt\u0026rsquo;s internal state is up to date and this prevents strange race conditions.\n Events slack.MessageEvent Notice this is not where messages are routed to listeners. The event loop is internal to bawt and only important for keeping bawt\u0026rsquo;s core state inline.\ngraph LR; A[slack.MessageEvent] --|Incoming Message| B{Event Loop} B --|Determine by Type| C(slack.Message) C -.-|Normalize Message| D(\"\u0026Message{}\") C -.- E{ev.Msg.SubType} D -.- F(message_changed) D -.- G(channel_topic) D -.- H(channel_purpose) C -.-|Verify UserMap| I(bot.Users) C -.-|Verify ChannelMap| J(bot.Channels) C -.-|Mutate Message| K(applyMentionsMe) C -.-|Mutate Message| L(applyFromMe) B --|Dispatch to Listeners| M((Dispatcher)) M -.- N(Listener A) N -.-|Message Handler| O(bawt.Listener.filterAndDispatchMessage) O -.- Q(bawt.Listener.filterMessage) Q -.- R(bawt.Listener.MessageHandlerFunc) N -.-|Event Handler| P(bawt.Listener.EventHandlerFunc)  "
},
{
	"uri": "https://capstonelabs.github.io/bawt/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Bawt is a chatops framework rather than a bot in itself. This means we don\u0026rsquo;t provide things like the scaffolding for a command line but it also means we remain fairly extensible. This structure allows teams to run their own Bawt without every Bawt being the same.\nUsing Bawt is so simple that two files is all it takes! Our mission is to make Bawt easy and fun to use for everyone, so follow along and let\u0026rsquo;s connect our first bot!\nYour First Bot This tutorial will assume you are working out of your home directory (~ or $HOME)\n1. Create a new directory for our bot:\n mkdir new-bot \u0026amp;\u0026amp; cd new-bot  2. New-Bot will need a binary, so let\u0026rsquo;s create a minimal main.go. The contents should resemble this:\npackage main import ( \u0026quot;flag\u0026quot; \u0026quot;github.com/gopherworks/bawt\u0026quot; _ \u0026quot;github.com/gopherworks/bawt/help\u0026quot; ) // Specify an alternative config file. bawt searches the working // directory and your home folder by default for a file called // `config.json`, `config.yaml`, or `config.toml` if no config // file is specified var configFile = flag.String(\u0026quot;config\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;config file\u0026quot;) func main() { flag.Parse() bot := bawt.New(*configFile) bot.Run() }   Turn your eyes to the imports for just a second. Bawt\u0026rsquo;s code takes advantage of imports with blank identifiers and the package init() functions to load plugins. You do not need to download plugins, as long as you obtain them using modules they\u0026rsquo;ll be versioned for you as well!  3. Almost there! Let\u0026rsquo;s tell New-Bot how to connect to Slack. Reading through our code earlier we\u0026rsquo;re looking for a config file. Bawt will always look for config.(json|yaml|toml) in the current directory and your home directory by default, but bawt.New() takes an optional pointer to override this file.\n{ \u0026quot;Slack\u0026quot;: { \u0026quot;api_token\u0026quot;: \u0026quot;xoxb-mamamamama-papapapapapapapa\u0026quot;, \u0026quot;nickname\u0026quot;: \u0026quot;username\u0026quot;, \u0026quot;general_channel\u0026quot;: \u0026quot;#general\u0026quot;, \u0026quot;team_domain\u0026quot;: \u0026quot;your-team-domain-name\u0026quot;, \u0026quot;join_channels\u0026quot;: [ \u0026quot;#some\u0026quot;, \u0026quot;#other\u0026quot;, \u0026quot;private_group\u0026quot; ], \u0026quot;web_base_url\u0026quot;: \u0026quot;http://host.example.com\u0026quot;, \u0026quot;db_path\u0026quot;: \u0026quot;./bawt.bolt.db\u0026quot; }, \u0026quot;Server\u0026quot;:{ \u0026quot;pid_file\u0026quot;: \u0026quot;/var/run/bawt.pid-or-empty-string\u0026quot; }, }   Each plugin may require different configuration entries but Server and Slack are the two required entries.  4. To make things easy, let\u0026rsquo;s build a Makefile!\nclean: @printf \u0026quot;# Removing vendor dir\\n\u0026quot; @rm -rf vendor @printf \u0026quot;# Removing build dir\\n\u0026quot; @rm -rf build build: clean vendor @env GO111MODULE=on go build -o build/new-bot . @chmod a+x build/new-bot vendor: @go mod tidy @go mod vendor run: ./bawt/new-bot --config config.json  That\u0026rsquo;s it! We\u0026rsquo;re ready to fire New-Bot up!\nmake run\nClick the arrow to read about putting your bot in Docker, Docker-Compose, and Kubernetes!\n"
},
{
	"uri": "https://capstonelabs.github.io/bawt/running-bawt/kubernetes/",
	"title": "Kubernetes",
	"tags": [],
	"description": "",
	"content": "The Kubernetes manifests are currently being iterated on.\n"
},
{
	"uri": "https://capstonelabs.github.io/bawt/developers/plugins/",
	"title": "Plugins",
	"tags": [],
	"description": "",
	"content": "  Types  Chat Plugins Chat Plugins use the PluginInitializer interface. Listeners In bawt one way you can interact with users is over chat. A listener is capable of listening for messages that align with a multitude of criteria. Fields In bawt listeners are structs that are highly configurable via various fields. Let\u0026rsquo;s take a look at the options: Field Type Description Name string Name of the app. Web Plugins Web plugins primarily rely on gorilla/mux to serve HTTP or HTTPS pages.\n Loading Config  Bawt lets plugins consume configuration just the same way Bawt does. bawt.LoadConfig() can be utilized to marshal a struct that has fields you\u0026rsquo;re looking for. Let\u0026rsquo;s take a look at what that looks like in practice: Let\u0026rsquo;s say we\u0026rsquo;re developing a plugin called Sample Plugin type SamplePlugin struct { bot *bawt.Bot } SamplePlugin needs some config though. type PluginConfig struct { Foo string `json:\u0026quot;foo\u0026quot;` Bar string `json:\u0026quot;bar\u0026quot;` Foobar string `json:\u0026quot;foobar\u0026quot;` } Bawt utilizes Viper under the hood, so if you\u0026rsquo;re familiar with Viper then you\u0026rsquo;ll find working with Bawt\u0026rsquo;s config loader very simple.\n All of Bawt\u0026rsquo;s plugins start with a single struct. This struct stores configuration data that will be unmarshaled to it during the init process.\nAt a minimum a field called bot which is a pointer of type bawt.Bot. This field is required in order to create your first listener, so don\u0026rsquo;t forget it!\ntype Help struct { bot *bawt.Bot }  We\u0026rsquo;ll then use Go\u0026rsquo;s built in init() function to register the plugin at runtime:\nfunc init() { bawt.RegisterPlugin(\u0026amp;Help{}) }  Now our plugin is registered, but it still needs to be initialized.\nOn the next page we\u0026rsquo;ll be learning about the different plugin types and the methods they support!\n"
},
{
	"uri": "https://capstonelabs.github.io/bawt/developers/plugins/types/",
	"title": "Types",
	"tags": [],
	"description": "",
	"content": "  Chat Plugins  Chat Plugins use the PluginInitializer interface. Listeners In bawt one way you can interact with users is over chat. A listener is capable of listening for messages that align with a multitude of criteria. Fields In bawt listeners are structs that are highly configurable via various fields. Let\u0026rsquo;s take a look at the options: Field Type Description Name string Name of the app.\n Web Plugins  Web plugins primarily rely on gorilla/mux to serve HTTP or HTTPS pages. Most of the setup of a web plugin is done inside the InitWebPlugin function. You\u0026rsquo;re provided a reference to the bot, a private router, and a public router. Let\u0026rsquo;s look at the example below: func (wp *WebPlugin) InitWebPlugin(bot *bawt.Bot, privRouter *mux.Router, pubRouter *mux.Router) { // Storing the bawt reference wp.bot = bot // Load some config; see: https://gopherworks.github.io/bawt/developers/plugins/20-useful-functions/ var conf struct { wp wpConfig } bot.\n All plugin types are interfaces. Your plugin struct should satisfy the desired interface.\nYou are not limited to using a singular interface.\n PluginInitializer This is the basic chat plugin interface. The core of this interface is the bawt.Listener struct which provides extensive abilities to both listen to and respond to users in a variety of ways.\nMethods    Method Description     InitPlugin(*Bot) Used to load config and register listeners    WebServer The purpose of this plugin is to start a web server. Bawt comes with a built in web server with both a public and private router. The web server interface should not be used more than once.\nMethods    Method Description     InitWebServer(*Bot, []string) Used to load config and create routers   RunServer() This method is called by Bawt to start up the web server in a go routine   SetAuthMiddleware(func(http.Handler) http.Handler) Used to inject authentication middleware   SetAuthenticatedUserFunc(func(req *http.Request) (*slack.User, error)) The function to be executed when a user attempts to auth   PrivateRouter() *mux.Router Returns a private router   PublicRouter() *mux.Router Returns a public router   GetSession(*http.Request) *sessions.Session Returns a session for an HTTP Request   AuthenticatedUser(*http.Request) (*slack.User, error) Determines the authenticated user    WebPlugin A web plugin is a plugin that can serve web pages on Bawt\u0026rsquo;s web server.\nMethods    Method Description     InitWebPlugin(bot *Bot, private *mux.Router, public *mux.Router) Used to load config and register routes    WebServerAuth WebServerAuth allows authentication to web services, such as through Slack, so that you can verify a user is who they say they are. WebServerAuth was mostly built on top of OAuth.\n   Method Description     InitWebServerAuth(bot *Bot, webserver WebServer) Initializes a web server auth plugin. Used to register the plugin and load config.    "
},
{
	"uri": "https://capstonelabs.github.io/bawt/developers/plugins/types/20-chat-plugins/",
	"title": "Chat Plugins",
	"tags": [],
	"description": "",
	"content": " Chat Plugins use the PluginInitializer interface.\nListeners In bawt one way you can interact with users is over chat. A listener is capable of listening for messages that align with a multitude of criteria.\nFields In bawt listeners are structs that are highly configurable via various fields. Let\u0026rsquo;s take a look at the options:\n   Field Type Description     Name string Name of the app. Used during app listing.   Description string Description of the app. Used during app listing.   Slug string Slug is a short code used in the help menu   Commands []Command Commands are the help documentation for commands   ListenUntil time.Time ListenUntil sets an absolute date at which this Listener expires and stops listening. ListenUntil and ListenDuration are optional and mutually exclusive.   ListenDuration time.Duration ListenDuration sets a timeout Duration, after which this Listener stops listening and is garbage collected. A call to ResetTimeout() restarts the listening period for another ListenDuration.   FromUser *slack.User FromUser filters out incoming messages that are not with *User (publicly or privately)   FromChannel *Channel FromChannel filters messages that are sent to a different room than Room. This can be mixed and matched with FromUser   FromAdmin bool FromAdmin filters messages that are only meant to be said by an admin   FromGroup []slack.Group FromGroup filters messages that are not from these groups   FromInternalGroup []string FromInternalGroup filters out messages not from these groups   PrivateOnly bool PrivateOnly filters out public messages   PublicOnly bool PublicOnly filters out private messages. Mutually exclusive with PrivateOnly   Contains string Contains checks whether the string is in the message body (after lower-casing both components)   ContainsAny []string ContainsAny checks that any one of the specified strings exist as substrings in the message body. Mutually exclusive with Contains   Matches *regexp.Regexp Matches checks that the given text matches the given Regexp with a FindStringSubmatch call. It will set the Message.Match attribute. If you spin off a goroutine in the MessageHandlerFunc, make sure to keep a copy of the Message.Match object because it will be overwritten by the next Listener the moment your MessageHandlerFunc unblocks    ListenForEdits bool ListenForEdits will trigger a message when a user edits a message as well as creates a new one   MentionsMeOnly bool MentionsMe filters out messages that do not mention the Bot\u0026rsquo;s bot.Config.MentionName   MatchMyMessages bool MatchMyMessages equal to false filters out messages that the bot itself sent.   MessageHandlerFunc func(*Listener, *Message) MessageHandlerFunc is a handling function provided by the user, and called when a relevant message comes in   EventHandlerFunc func(*Listener, interface{}) EventHandlerFunc is a handling function provided by the user, and called when any event is received. These messages are dispatched to each Listener in turn, after the bot has processed it. If the event is a Message, then the bawt.Message will be non-nil. When receiving a *slack.MessageEvent, bawt will wrap it in a *bawt.Message which embeds the the original event, but adds quite a few functionalities, like reply modes, etc..   TimeoutFunc func(*Listener) TimeoutFunc is called when a conversation expires after ListenDuration or ListenUntil delays. It is not called if you explicitly call Close() on the conversation, or if you did not set ListenDuration nor ListenUntil. Also, if you override TimeoutFunc, you need to call Close() yourself otherwise, the conversation is not removed from the listeners   Bot *Bot Bot is a reference to the bot instance. It will always be populated before being passed to handler functions.    Methods Methods extend granular control to developers, allowing them to manually close a listener, control ACK\u0026rsquo;s to Slack\u0026rsquo;s servers, and reset timers.\n   Method Description     Close() Close terminates the Listener management goroutine, and stops any further listening and message handling   ReplyAck() ReplyAck returns the AckMessage received that corresponds to the Reply on which you called Listen()   ResetDuration() ResetDuration re-initializes the timeout set by Listener.ListenDuration, and continues listening for another such duration.    Message Handling When you receive a message after it matches the criteria given by a bawt.Listener you will receive it as a struct called bawt.Message.\nFields    Field Type Description     *slack.Msg  Allows you to accesss the underlying Slack message primitive   SubMessage *slack.Msg Threaded replies   MentionsMe bool Does the user @mention the bot   IsEdit bool Is this message the result of an edit   FromMe bool Was the message from the bot   FromUser *slack.User The user who sent the message   FromChannel *Channel The channel the message was received in, including direct messages   Match []string Match contains the result of Listener.Matches.FindStringSubmatch(msg.Text), when Matches is set on the Listener.    Methods    Function Signature Description     AddReaction(emoticon string) *Message AddReaction adds a reaction to a message   Contains(s string) bool Contains searches for a single string in a noncase-sensitive fashion   ContainsAll(strs []string) bool ContainsAll searches for all strings in a noncase-sensitive fashion   ContainsAny(strs []string) bool ContainsAny searches for at least one noncase-sensitive matching string   ContainsAnyCased(strs []string) bool ContainsAnyCased searches for at least one case-sensitive word   HasPrefix(prefix string) bool HasPrefix returns true if a message starts with a given string   IsPrivate() bool IsPrivate determines if a message is private or not   ListenReaction(reactListen *ReactionListener) ListenReaction listens for a reaction on a message   RemoveReaction(emoticon string) *Message RemoveReaction removes a reaction from a message   Reply(text string, v ...interface{}) *Reply Reply sends a message back to the source it came from, without a mention   ReplyMention(text string, v ...interface{}) *Reply ReplyMention replies with a @mention named prefixed, when replying in public. When replying in private, nothing is added.   ReplyPrivately(text string, v ...interface{}) *Reply ReplyPrivately replies to the user in an IM   ReplyWithFile(p FileUploadParameters) *ReplyWithFile ReplyWithFile replies with a snippet or an attached file   String() string String returns a message with field:value as a string    "
},
{
	"uri": "https://capstonelabs.github.io/bawt/running-bawt/docker/",
	"title": "Docker",
	"tags": [],
	"description": "",
	"content": "This assumes a Dockerfile in the same folder as your main package with modules and vendoring.\nFROM golang:alpine as builder RUN mkdir /build COPY . /build WORKDIR /build RUN apk add --update musl-dev gcc go git mercurial RUN env GO111MODULE=on go build -mod=vendor -o builds/bot . FROM alpine RUN apk --no-cache add ca-certificates RUN adduser -S -D -H -h /app appuser USER appuser RUN id COPY --from=builder /build/builds/bot /app/ WORKDIR /app CMD [\u0026quot;./bot\u0026quot;]  "
},
{
	"uri": "https://capstonelabs.github.io/bawt/running-bawt/",
	"title": "Running bawt",
	"tags": [],
	"description": "",
	"content": "Optomized bawt configuration is available for bawts. This configuration expects that you have an entrypoint (binary) called bot that takes an argument of run-server, however, you may customize it to your liking.\n Kubernetes  The Kubernetes manifests are currently being iterated on.\n Docker  This assumes a Dockerfile in the same folder as your main package with modules and vendoring. FROM golang:alpine as builder RUN mkdir /build COPY . /build WORKDIR /build RUN apk add --update musl-dev gcc go git mercurial RUN env GO111MODULE=on go build -mod=vendor -o builds/bot . FROM alpine RUN apk --no-cache add ca-certificates RUN adduser -S -D -H -h /app appuser USER appuser RUN id COPY --from=builder /build/builds/bot /app/ WORKDIR /app CMD [\u0026quot;.\n Docker Compose  The following configuration is how we do local development with Docker Compose. version: '3.7' services: bot: image: 'your/docker-image:latest' restart: always command: - ./bot - runserver ports: - \u0026quot;8080:8080\u0026quot; volumes: - type: bind source: ./bot.bolt.db target: /bot.bolt.db read_only: false - type: bind source: ./config.yaml target: /config.yaml read_only: false  "
},
{
	"uri": "https://capstonelabs.github.io/bawt/developers/",
	"title": "Developers",
	"tags": [],
	"description": "",
	"content": "  Plugins  Types Chat Plugins Chat Plugins use the PluginInitializer interface. Listeners In bawt one way you can interact with users is over chat. A listener is capable of listening for messages that align with a multitude of criteria. Fields In bawt listeners are structs that are highly configurable via various fields. Let\u0026rsquo;s take a look at the options: Field Type Description Name string Name of the app. Web Plugins Web plugins primarily rely on gorilla/mux to serve HTTP or HTTPS pages.\n Datastores   Bawt has built in support for BoltDB Why Bolt? You can read more about Bolt above, but this is why Bolt has stayed a part of Bawt: Simple Lightweight Resilient That said, Bolt isn\u0026rsquo;t meant for everything. If you have a usecase for a different datastore then add it! Tools BoltDB Web - A web frontend for browsing BoltDB Bolt Browser - A command line browser for BoltDB Bolter - A machine friendly CLI for interrogating BoltDB  Design   These design docs are purposed to drive a high level understanding of Bawt\u0026rsquo;s functionality. Read On Event Loop The event loop is designed to keep Bawt\u0026#39;s internal state in line as well as pass messages to listeners.  Whether you\u0026rsquo;re developing on Bawt\u0026rsquo;s core functionality or a new plugin, development should always be fun. If you spot something that\u0026rsquo;s not enjoyable then open an issue and let\u0026rsquo;s start fixing it together.\nPrerequisites  Read the Code of Conduct Read our Contributing Guide  Design Plugins are Go packages in bawt. They are anonymously imported by your main package.\nPlugins are represented by structs. At a minimum your plugin struct should include the field bot *bawt.Bot.\nPlugins take advantage of the init() function where you call bawt.RegisterPlugin(\u0026amp;Help{})\nYou\u0026rsquo;ll read more later on about the various plugin interfaces.\n"
},
{
	"uri": "https://capstonelabs.github.io/bawt/running-bawt/docker-compose/",
	"title": "Docker Compose",
	"tags": [],
	"description": "",
	"content": "The following configuration is how we do local development with Docker Compose.\nversion: '3.7' services: bot: image: 'your/docker-image:latest' restart: always command: - ./bot - runserver ports: - \u0026quot;8080:8080\u0026quot; volumes: - type: bind source: ./bot.bolt.db target: /bot.bolt.db read_only: false - type: bind source: ./config.yaml target: /config.yaml read_only: false  "
},
{
	"uri": "https://capstonelabs.github.io/bawt/developers/plugins/20-useful-functions/",
	"title": "Loading Config",
	"tags": [],
	"description": "",
	"content": "Bawt lets plugins consume configuration just the same way Bawt does.\nbawt.LoadConfig() can be utilized to marshal a struct that has fields you\u0026rsquo;re looking for. Let\u0026rsquo;s take a look at what that looks like in practice:\nLet\u0026rsquo;s say we\u0026rsquo;re developing a plugin called Sample Plugin\ntype SamplePlugin struct { bot *bawt.Bot }  SamplePlugin needs some config though.\ntype PluginConfig struct { Foo string `json:\u0026quot;foo\u0026quot;` Bar string `json:\u0026quot;bar\u0026quot;` Foobar string `json:\u0026quot;foobar\u0026quot;` }  Bawt utilizes Viper under the hood, so if you\u0026rsquo;re familiar with Viper then you\u0026rsquo;ll find working with Bawt\u0026rsquo;s config loader very simple. Bawt can accept JSON, YAML, or TOML.\nThis config needs to be stored somewhere! Let\u0026rsquo;s modify our plugin struct:\ntype SamplePlugin struct { bot *bawt.Bot config *PluginConfig }  The InitPlugin method is called directly after the plugin has loaded. This is a good place to wire up our configuration:\nfunc (s *SamplePlugin) InitPlugin(b *bawt.Bot) { // The field name here is how our config field will be named var conf struct { SamplePlugin PluginConfig } // Drop bot into the plugin struct s.bot = b bot.LoadConfig(\u0026amp;conf) s.config = \u0026amp;conf.SamplePlugin }  This method utilizes a pointer receiver because it modifies our plugin struct.\n Now if our config goes like this\u0026hellip;\nConfig: ... SamplePlugin: foo: bar bar: foo foobar: barfoo  Bawt will pick up the SamplePlugin object and unmarshal it to your struct which is accessible by\nfunc (s SamplePlugin) someFunc() { fmt.Printf(\u0026quot;Sample plugin foo: %s\u0026quot;, s.config.foo) }  You\u0026rsquo;ve now successfully made Bawt load plugin config on your behalf!\n"
},
{
	"uri": "https://capstonelabs.github.io/bawt/developers/plugins/types/30-web-plugins/",
	"title": "Web Plugins",
	"tags": [],
	"description": "",
	"content": "Web plugins primarily rely on gorilla/mux to serve HTTP or HTTPS pages. Most of the setup of a web plugin is done inside the InitWebPlugin function. You\u0026rsquo;re provided a reference to the bot, a private router, and a public router. Let\u0026rsquo;s look at the example below:\nfunc (wp *WebPlugin) InitWebPlugin(bot *bawt.Bot, privRouter *mux.Router, pubRouter *mux.Router) { // Storing the bawt reference wp.bot = bot // Load some config; see: https://gopherworks.github.io/bawt/developers/plugins/20-useful-functions/ var conf struct { wp wpConfig } bot.LoadConfig(\u0026amp;conf) wp.config = conf.wp // The public router uses /public as a prefix pubRouter.HandleFunc(\u0026quot;/public/ping\u0026quot;, wp.handlePing) // The private router runs on localhost privRouter.HandleFunc(\u0026quot;/healthz\u0026quot;, wp.handleHealthcheck) }  As you can see we load some configuration using bawt\u0026rsquo;s built in functionality for loading it\u0026rsquo;s core configuration. Next we setup a route on the public router for /public/ping and send it to a method called handlePing. This router is served on the IP address specified in the configuration.\nPrivate routers are just the same except they serve on localhost.\n"
},
{
	"uri": "https://capstonelabs.github.io/bawt/developers/20-datastores/",
	"title": "Datastores",
	"tags": [],
	"description": "",
	"content": " Bawt has built in support for BoltDB\nWhy Bolt? You can read more about Bolt above, but this is why Bolt has stayed a part of Bawt:\n Simple Lightweight Resilient  That said, Bolt isn\u0026rsquo;t meant for everything. If you have a usecase for a different datastore then add it!\nTools  BoltDB Web - A web frontend for browsing BoltDB Bolt Browser - A command line browser for BoltDB Bolter - A machine friendly CLI for interrogating BoltDB  "
},
{
	"uri": "https://capstonelabs.github.io/bawt/press-kit/",
	"title": "Press Kit",
	"tags": [],
	"description": "",
	"content": " Authorized logos   Logos   bawt-colored.png  (24 ko)   bawt-colored.svg  (33 ko)   bawt-white.png  (23 ko)   bawt-white.svg  (33 ko)    The logos use Prosto One as their font.\nColors are: #00baff and #ffffff\n"
},
{
	"uri": "https://capstonelabs.github.io/bawt/code-of-conduct/",
	"title": "Code of Conduct",
	"tags": [],
	"description": "",
	"content": " Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\nOur Standards Examples of behavior that contributes to creating a positive environment include:\n Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members  Examples of unacceptable behavior by participants include:\n The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others\u0026rsquo; private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting  Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\nScope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\nEnforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at matthew.ouille@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project\u0026rsquo;s leadership.\nAttribution This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at http://contributor-covenant.org/version/1/4\n"
},
{
	"uri": "https://capstonelabs.github.io/bawt/developers/design/",
	"title": "Design",
	"tags": [],
	"description": "",
	"content": " These design docs are purposed to drive a high level understanding of Bawt\u0026rsquo;s functionality.\nRead On  Event Loop  The event loop is designed to keep Bawt\u0026#39;s internal state in line as well as pass messages to listeners.\n "
},
{
	"uri": "https://capstonelabs.github.io/bawt/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://capstonelabs.github.io/bawt/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://capstonelabs.github.io/bawt/",
	"title": "home",
	"tags": [],
	"description": "",
	"content": " Bawt is a Slack bot framework written in Go. Our goal is that bawt is always easy to start, easy to run, easy to enhance\nEasy to start. The single biggest turn off I had when trying out a new project was the amount of time it took me to get started with something meaningful. The plugin footprint is intentionally light yet extensive and why Bawt\u0026rsquo;s core can be started with just two files. We aim to strike a rare balance of extensibility and simplicity.\nEasy to run. Bawt is updated via modules and follows Semantic Versioning (SemVer) so you\u0026rsquo;ll always know what sort of changes await you. Bawt\u0026rsquo;s core code is abstracted into the Messaging API so even when Slack breaks their API\u0026rsquo;s (and they will) you will never notice as a plugin developer.\nEasy to enhance. We want Bawt\u0026rsquo;s code to make sense not just to core developers but to plugin devs as well. That\u0026rsquo;s why Bawt\u0026rsquo;s core is both verbose and descriptive. There\u0026rsquo;s no buried functionality, what you see is what you get.\nFeatures This is by far not a comprehensive list\n Easy to start, Easy to maintain, Easy to enhance Plugin API  Single function registration Built in help docs interface Chat, HTTP, or HTTPAuth type plugins  Messaging API  Channel and DM\u0026rsquo;s Public and private messages Ephemeral messages (disappear after duration) Update previously sent message File and Snippet uploads  Listener API  Dynamic registration and deregistration Listen for Messages, Edits, Reactions\u0026hellip; Regex and contains based checks  BoltDB for data persistence Central Slack event loop Tracks state internally (Channels, Users, and their state) Built in web server that support authentication  Communication between web plugins and chat plugins  Uses modules for versioning  "
}]